var searchIndex = JSON.parse('{\
"bad_upwind":{"doc":"The <code>bad_upwind</code> crate provides a means to find out what …","t":"AAFADLLLMLLLLMMFLMLLLMFNENDLLLLLLLLLLLLLLLLLLLLLL","n":["input","output","run","upwind_solver","InputParams","borrow","borrow_mut","deserialize","dt","eq","fmt","from","into","n_x","ncycle_out","read_input_params","serialize","t_max","try_from","try_into","type_id","v_adv","output","Backward","DiffMethod","Forward","UpwindSolver","borrow","borrow","borrow_mut","borrow_mut","borrow_u","fmt","fmt","from","from","get_step","get_t","integrate","into","into","is_completed","new","try_from","try_from","try_into","try_into","type_id","type_id"],"q":[[0,"bad_upwind"],[4,"bad_upwind::input"],[22,"bad_upwind::output"],[23,"bad_upwind::upwind_solver"]],"d":["Module to read the input parameters.","Module to output the results.","Run the solver and output the results.","Solver for the transport equation using upwind method.","Input parameters.","","","","Time step.","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Number of cells.","Number of cycles between outputs.","Read the input parameters from the input in YAML format.","","Maximum time.","","","","Advection velocity.","Output the results.","Backward difference method.","Difference methods.","Forward difference method.","Solver for the transport equation using upwind method.","","","","","Return a reference to the current <code>u</code>.","","","Returns the argument unchanged.","Returns the argument unchanged.","Return the current <code>step</code>.","Return the current <code>t</code>.","Integrate the transport equation by one time step.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Return <code>true</code> if the calculation has been completed.","Create a new <code>UpwindSolver</code> instance.","","","","","",""],"i":[0,0,0,0,0,10,10,10,10,10,10,10,10,10,10,0,10,10,10,10,10,10,0,18,0,18,0,3,18,3,18,3,3,18,3,18,3,3,3,3,18,3,3,3,18,3,18,3,18],"f":[0,0,[[[2,[1]],3,4,5],[[8,[[7,[6]]]]]],0,0,[[]],[[]],[9,[[8,[10]]]],0,[[10,10],11],[[10,12],13],[[]],[[]],0,0,[14,[[8,[10,[7,[6]]]]]],[[10,15],8],0,[[],8],[[],8],[[],16],0,[[4,1,[2,[1]],[2,[1]]],[[8,[17]]]],0,0,0,0,[[]],[[]],[[]],[[]],[3,[[2,[1]]]],[[3,12],13],[[18,12],13],[[]],[[]],[3,5],[3,1],[3,[[8,[19]]]],[[]],[[]],[3,11],[[[2,[1]],1,1,1,1,18],3],[[],8],[[],8],[[],8],[[],8],[[],16],[[],16]],"c":[],"p":[[15,"f64"],[6,"Array1"],[3,"UpwindSolver"],[8,"Write"],[15,"usize"],[8,"Error"],[3,"Box"],[4,"Result"],[8,"Deserializer"],[3,"InputParams"],[15,"bool"],[3,"Formatter"],[6,"Result"],[8,"Read"],[8,"Serializer"],[3,"TypeId"],[3,"Error"],[4,"DiffMethod"],[15,"str"]]},\
"elliptic":{"doc":"This crate provides a means of comparing the convergence …","t":"AAFAIFKFIIKKKAAKDDLLLLLLLLLLLLMLLLLLLLMLDDLLLLLLLLLLLLMLMLLLLLLML","n":["input","output","run","solver","InputParams","read_input_params","validate_params","output","NewParams","Solver","borrow_u","exec","get_n_iter","point_jacobi_solver","sor_solver","validate_new_params","PointJacobiSolver","PointJacobiSolverNewParams","borrow","borrow","borrow_mut","borrow_mut","borrow_u","exec","fmt","from","from","get_n_iter","into","into","n_iter_max","new","try_from","try_from","try_into","try_into","type_id","type_id","u_init","validate_new_params","SorSolver","SorSolverNewParams","borrow","borrow","borrow_mut","borrow_mut","borrow_u","exec","fmt","from","from","get_n_iter","into","into","n_iter_max","new","omega","try_from","try_from","try_into","try_into","type_id","type_id","u_init","validate_new_params"],"q":[[0,"elliptic"],[4,"elliptic::input"],[7,"elliptic::output"],[8,"elliptic::solver"],[16,"elliptic::solver::point_jacobi_solver"],[40,"elliptic::solver::sor_solver"]],"d":["Module to read the input parameters.","Module to output the results.","Run the solver and output the results.","Solvers for the diffusion equation.","Input parameters.","Read the input parameters from the input.","Validate the input parameters.","Output the results.","Parameters for creating a new solver.","Solver for the diffusion equation.","Return a reference to <code>u</code>.","Execute solving the diffusion equation.","Return the number of iterations.","Solver for the diffusion equation using the Point Jacobi …","Solver for the diffusion equation using the SOR method.","Validate the parameters for creating a new solver.","Solver for the diffusion equation using the Point Jacobi …","Parameters for creating a new <code>PointJacobiSolver</code> instance.","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Maximum number of iterations.","Create a new <code>PointJacobiSolver</code> instance.","","","","","","","Initial values of <code>u</code>.","","Solver for the diffusion equation using the SOR method.","Parameters for creating a new <code>SorSolver</code> instance.","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Maximum number of iterations.","Create a new <code>SorSolver</code> instance.","Relaxation parameter.","","","","","","","Initial values of <code>u</code>.",""],"i":[0,0,0,0,0,0,7,0,0,0,1,1,1,0,0,22,0,0,18,15,18,15,15,15,15,18,15,15,18,15,18,15,18,15,18,15,18,15,18,18,0,0,21,20,21,20,20,20,20,21,20,20,21,20,21,20,21,21,20,21,20,21,20,21,21],"f":[0,0,[[1,2],[[5,[[4,[3]]]]]],0,0,[6,[[5,[[0,[7,8,9]],[4,[3]]]]]],[[],[[5,[10]]]],[[2,[12,[11]]],[[5,[13]]]],0,0,[[],[[12,[11]]]],[[],[[5,[[4,[3]]]]]],[[],14],0,0,[[],[[5,[10]]]],0,0,[[]],[[]],[[]],[[]],[15,[[12,[11]]]],[15,[[5,[[4,[3]]]]]],[[15,16],17],[[]],[[]],[15,14],[[]],[[]],0,[18,[[5,[15,10]]]],[[],5],[[],5],[[],5],[[],5],[[],19],[[],19],0,[18,[[5,[10]]]],0,0,[[]],[[]],[[]],[[]],[20,[[12,[11]]]],[20,[[5,[[4,[3]]]]]],[[20,16],17],[[]],[[]],[20,14],[[]],[[]],0,[21,[[5,[20,10]]]],0,[[],5],[[],5],[[],5],[[],5],[[],19],[[],19],0,[21,[[5,[10]]]]],"c":[],"p":[[8,"Solver"],[8,"Write"],[8,"Error"],[3,"Box"],[4,"Result"],[8,"Read"],[8,"InputParams"],[8,"Serialize"],[8,"DeserializeOwned"],[15,"str"],[15,"f64"],[6,"Array2"],[3,"Error"],[15,"usize"],[3,"PointJacobiSolver"],[3,"Formatter"],[6,"Result"],[3,"PointJacobiSolverNewParams"],[3,"TypeId"],[3,"SorSolver"],[3,"SorSolverNewParams"],[8,"NewParams"]]},\
"linear_hyperbolic":{"doc":"This crate provides a means of comparing the stability of …","t":"AAAFAIFKADLLLLLLLLLLFIIAKAKKKAAAAAKDDLLLLLLLLLLLLLMMLMLLLLLLMLDDLLLLLLLLLLLLLMLMLLLLLLMLDDLLLLLLLLLLLLLMLMLLLLLLMLDDLLLLLLLLLLLLLMLMLLLLLLMLDDLLLLLLLLLLLLLMLMLLLLLLMLDDLLLLLLLLLLLLLMLMLLLLLLMLDDLLLLLLLLLLLLLMLMLLLLLLML","n":["input","math","output","run","solver","InputParams","read_input_params","validate_params","trinomial_eq","TrinomialEq","borrow","borrow_mut","fmt","from","into","new","solve","try_from","try_into","type_id","output","NewParams","Solver","beamwarming_solver","borrow_u","ftcs_solver","get_step","integrate","is_completed","lax_solver","laxwendroff_solver","leapfrog_solver","maccormack_solver","upwind_solver","validate_new_params","BeamwarmingSolver","BeamwarmingSolverNewParams","borrow","borrow","borrow_mut","borrow_mut","borrow_u","fmt","from","from","get_step","integrate","into","into","is_completed","lambda","n_cfl","new","step_max","try_from","try_from","try_into","try_into","type_id","type_id","u","validate_new_params","FtcsSolver","FtcsSolverNewParams","borrow","borrow","borrow_mut","borrow_mut","borrow_u","fmt","from","from","get_step","integrate","into","into","is_completed","n_cfl","new","step_max","try_from","try_from","try_into","try_into","type_id","type_id","u","validate_new_params","LaxSolver","LaxSolverNewParams","borrow","borrow","borrow_mut","borrow_mut","borrow_u","fmt","from","from","get_step","integrate","into","into","is_completed","n_cfl","new","step_max","try_from","try_from","try_into","try_into","type_id","type_id","u","validate_new_params","LaxwendroffSolver","LaxwendroffSolverNewParams","borrow","borrow","borrow_mut","borrow_mut","borrow_u","fmt","from","from","get_step","integrate","into","into","is_completed","n_cfl","new","step_max","try_from","try_from","try_into","try_into","type_id","type_id","u","validate_new_params","LeapfrogSolver","LeapfrogSolverNewParams","borrow","borrow","borrow_mut","borrow_mut","borrow_u","fmt","from","from","get_step","integrate","into","into","is_completed","n_cfl","new","step_max","try_from","try_from","try_into","try_into","type_id","type_id","u","validate_new_params","MaccormackSolver","MaccormackSolverNewParams","borrow","borrow","borrow_mut","borrow_mut","borrow_u","fmt","from","from","get_step","integrate","into","into","is_completed","n_cfl","new","step_max","try_from","try_from","try_into","try_into","type_id","type_id","u","validate_new_params","UpwindSolver","UpwindSolverNewParams","borrow","borrow","borrow_mut","borrow_mut","borrow_u","fmt","from","from","get_step","integrate","into","into","is_completed","n_cfl","new","step_max","try_from","try_from","try_into","try_into","type_id","type_id","u","validate_new_params"],"q":[[0,"linear_hyperbolic"],[5,"linear_hyperbolic::input"],[8,"linear_hyperbolic::math"],[9,"linear_hyperbolic::math::trinomial_eq"],[20,"linear_hyperbolic::output"],[21,"linear_hyperbolic::solver"],[35,"linear_hyperbolic::solver::beamwarming_solver"],[62,"linear_hyperbolic::solver::ftcs_solver"],[88,"linear_hyperbolic::solver::lax_solver"],[114,"linear_hyperbolic::solver::laxwendroff_solver"],[140,"linear_hyperbolic::solver::leapfrog_solver"],[166,"linear_hyperbolic::solver::maccormack_solver"],[192,"linear_hyperbolic::solver::upwind_solver"]],"d":["Module to read the input parameters.","Math module.","Module to output the results.","Run the solver and output the results.","Solvers for the transport equation.","Input parameters.","Read the input parameters from the input.","Validate the input parameters.","Module for solving the trinomial equations.","Solver for the trinomial equations.","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Create a new <code>TrinomialEq</code> instance.","Solve the trinomial equation.","","","","Output the results.","Parameters for creating a new solver.","Solver for the transport equation.","Solver for the transport equation using the Beam-Warming …","Return a reference to the current <code>u</code>.","Solver for the transport equation using the FTCS method.","Return the current <code>step</code>.","Integrate the transport equation by one step.","Return <code>true</code> if the calculation has been completed.","Solver for the transport equation using the Lax method.","Solver for the transport equation using the Lax-Wendroff …","Solver for the transport equation using the Leap-Frog …","Solver for the transport equation using the MacCormack …","Solver for the transport equation using the upwind method.","Validate the parameters for creating a new solver.","Solver for the transport equation using the Beam-Warming …","Parameters for creating a new <code>BeamwarmingSolver</code> instance.","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","Weighting factor in differencing scheme.","CFL number.","Create a new <code>BeamwarmingSolver</code> instance.","Maximum number of time steps.","","","","","","","Initial values of <code>u</code>.","","Solver for the transport equation using the FTCS method.","Parameters for creating a new <code>FtcsSolver</code> instance.","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","CFL number.","Create a new <code>FtcsSolver</code> instance.","Maximum number of time steps.","","","","","","","Initial value of <code>u</code>.","","Solver for the transport equation using the Lax method.","Parameters for creating a new <code>LaxSolver</code> instance.","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","CFL number.","Create a new <code>LaxSolver</code> instance.","Maximum number of time steps.","","","","","","","Initial value of <code>u</code>.","","Solver for the transport equation using the Lax-Wendroff …","Parameters for creating a new <code>LaxwendroffSolver</code> instance.","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","CFL number.","Create a new <code>LaxwendroffSolver</code> instance.","Maximum number of time steps.","","","","","","","Initial value of <code>u</code>.","","Solver for the transport equation using the Leap-Frog …","Parameters for creating a new <code>LeapfrogSolver</code> instance.","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","CFL number.","Create a new <code>LeapfrogSolver</code> instance.","Maximum number of time steps.","","","","","","","Initial value of <code>u</code>.","","Solver for the transport equation using the MacCormack …","Parameters for creating a new <code>MaccormackSolver</code> instance.","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","CFL number.","Create a new <code>MaccormackSolver</code> instance.","Maximum number of time steps.","","","","","","","Initial value of <code>u</code>.","","Solver for the transport equation using the upwind method.","Parameters for creating a new <code>UpwindSolver</code> instance.","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","CFL number.","Create a new <code>UpwindSolver</code> instance.","Maximum number of time steps.","","","","","","","Initial value of <code>u</code>.",""],"i":[0,0,0,0,0,0,0,10,0,0,14,14,14,14,14,14,14,14,14,14,0,0,0,0,3,0,3,3,3,0,0,0,0,0,34,0,0,21,20,21,20,20,20,21,20,20,20,21,20,20,21,21,20,21,21,20,21,20,21,20,21,21,0,0,23,22,23,22,22,22,23,22,22,22,23,22,22,23,22,23,23,22,23,22,23,22,23,23,0,0,25,24,25,24,24,24,25,24,24,24,25,24,24,25,24,25,25,24,25,24,25,24,25,25,0,0,27,26,27,26,26,26,27,26,26,26,27,26,26,27,26,27,27,26,27,26,27,26,27,27,0,0,29,28,29,28,28,28,29,28,28,28,29,28,28,29,28,29,29,28,29,28,29,28,29,29,0,0,31,30,31,30,30,30,31,30,30,30,31,30,30,31,30,31,31,30,31,30,31,30,31,31,0,0,33,32,33,32,32,32,33,32,32,32,33,32,32,33,32,33,33,32,33,32,33,32,33,33],"f":[0,0,0,[[[2,[1]],3,4,5],[[8,[[7,[6]]]]]],0,0,[9,[[8,[[0,[10,11,12]],[7,[6]]]]]],[[],[[8,[13]]]],0,0,[[]],[[]],[[14,15],16],[[]],[[]],[2,14],[[14,[2,[1]]],[[8,[13]]]],[[],8],[[],8],[[],17],[[4,5,[2,[1]],[2,[1]]],[[8,[18]]]],0,0,0,[[],[[2,[1]]]],0,[[],5],[[],[[8,[[7,[6]]]]]],[[],19],0,0,0,0,0,[[],[[8,[13]]]],0,0,[[]],[[]],[[]],[[]],[20,[[2,[1]]]],[[20,15],16],[[]],[[]],[20,5],[20,[[8,[[7,[6]]]]]],[[]],[[]],[20,19],0,0,[21,[[8,[20,13]]]],0,[[],8],[[],8],[[],8],[[],8],[[],17],[[],17],0,[21,[[8,[13]]]],0,0,[[]],[[]],[[]],[[]],[22,[[2,[1]]]],[[22,15],16],[[]],[[]],[22,5],[22,[[8,[[7,[6]]]]]],[[]],[[]],[22,19],0,[23,[[8,[22,13]]]],0,[[],8],[[],8],[[],8],[[],8],[[],17],[[],17],0,[23,[[8,[13]]]],0,0,[[]],[[]],[[]],[[]],[24,[[2,[1]]]],[[24,15],16],[[]],[[]],[24,5],[24,[[8,[[7,[6]]]]]],[[]],[[]],[24,19],0,[25,[[8,[24,13]]]],0,[[],8],[[],8],[[],8],[[],8],[[],17],[[],17],0,[25,[[8,[13]]]],0,0,[[]],[[]],[[]],[[]],[26,[[2,[1]]]],[[26,15],16],[[]],[[]],[26,5],[26,[[8,[[7,[6]]]]]],[[]],[[]],[26,19],0,[27,[[8,[26,13]]]],0,[[],8],[[],8],[[],8],[[],8],[[],17],[[],17],0,[27,[[8,[13]]]],0,0,[[]],[[]],[[]],[[]],[28,[[2,[1]]]],[[28,15],16],[[]],[[]],[28,5],[28,[[8,[[7,[6]]]]]],[[]],[[]],[28,19],0,[29,[[8,[28,13]]]],0,[[],8],[[],8],[[],8],[[],8],[[],17],[[],17],0,[29,[[8,[13]]]],0,0,[[]],[[]],[[]],[[]],[30,[[2,[1]]]],[[30,15],16],[[]],[[]],[30,5],[30,[[8,[[7,[6]]]]]],[[]],[[]],[30,19],0,[31,[[8,[30,13]]]],0,[[],8],[[],8],[[],8],[[],8],[[],17],[[],17],0,[31,[[8,[13]]]],0,0,[[]],[[]],[[]],[[]],[32,[[2,[1]]]],[[32,15],16],[[]],[[]],[32,5],[32,[[8,[[7,[6]]]]]],[[]],[[]],[32,19],0,[33,[[8,[32,13]]]],0,[[],8],[[],8],[[],8],[[],8],[[],17],[[],17],0,[33,[[8,[13]]]]],"c":[],"p":[[15,"f64"],[6,"Array1"],[8,"Solver"],[8,"Write"],[15,"usize"],[8,"Error"],[3,"Box"],[4,"Result"],[8,"Read"],[8,"InputParams"],[8,"Serialize"],[8,"DeserializeOwned"],[15,"str"],[3,"TrinomialEq"],[3,"Formatter"],[6,"Result"],[3,"TypeId"],[3,"Error"],[15,"bool"],[3,"BeamwarmingSolver"],[3,"BeamwarmingSolverNewParams"],[3,"FtcsSolver"],[3,"FtcsSolverNewParams"],[3,"LaxSolver"],[3,"LaxSolverNewParams"],[3,"LaxwendroffSolver"],[3,"LaxwendroffSolverNewParams"],[3,"LeapfrogSolver"],[3,"LeapfrogSolverNewParams"],[3,"MaccormackSolver"],[3,"MaccormackSolverNewParams"],[3,"UpwindSolver"],[3,"UpwindSolverNewParams"],[8,"NewParams"]]},\
"parabolic":{"doc":"This crate provides a means of comparing the stability of …","t":"AAAFAIFKADLLLLLLLLLLFIIAKAKKKKDDLLLLLLLLLLLLLMMLMLLLLLLMLDDLLLLLLLLLLLLLMLMLLLLLLML","n":["input","math","output","run","solver","InputParams","read_input_params","validate_params","trinomial_eq","TrinomialEq","borrow","borrow_mut","fmt","from","into","new","solve","try_from","try_into","type_id","output","NewParams","Solver","beamwarming_solver","borrow_u","ftcs_solver","get_step","integrate","is_completed","validate_new_params","BeamwarmingSolver","BeamwarmingSolverNewParams","borrow","borrow","borrow_mut","borrow_mut","borrow_u","fmt","from","from","get_step","integrate","into","into","is_completed","lambda","mu","new","step_max","try_from","try_from","try_into","try_into","type_id","type_id","u","validate_new_params","FtcsSolver","FtcsSolverNewParams","borrow","borrow","borrow_mut","borrow_mut","borrow_u","fmt","from","from","get_step","integrate","into","into","is_completed","mu","new","step_max","try_from","try_from","try_into","try_into","type_id","type_id","u","validate_new_params"],"q":[[0,"parabolic"],[5,"parabolic::input"],[8,"parabolic::math"],[9,"parabolic::math::trinomial_eq"],[20,"parabolic::output"],[21,"parabolic::solver"],[30,"parabolic::solver::beamwarming_solver"],[57,"parabolic::solver::ftcs_solver"]],"d":["Module to read the input parameters.","Math module.","Module to output the results.","Run the solver and output the results.","Solvers for the diffusion equation.","Input parameters.","Read the input parameters from the input.","Validate the input parameters.","Module for solving the trinomial equations.","Solver for the trinomial equations.","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Create a new <code>TrinomialEq</code> instance.","Solve the trinomial equation.","","","","Output the results.","Parameters for creating a new solver.","Solver for the diffusion equation.","Solver for the diffusion equation using the Beam-Warming …","Return a reference to the current <code>u</code>.","Solver for the diffusion equation using the FTCS method.","Return the current <code>step</code>.","Integrate the transport equation by one step.","Return <code>true</code> if the calculation has been completed.","Validate the parameters for creating a new solver.","Solver for the diffusion equation using the Beam-Warming …","Parameters for creating a new <code>BeamwarmingSolver</code> instance.","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","Weighting factor in differencing scheme.","diffusion coefficient * dt / dx^2.","Create a new <code>BeamwarmingSolver</code> instance.","Maximum number of time steps.","","","","","","","Initial values of <code>u</code>.","","Solver for the diffusion equation using the FTCS method.","Parameters for creating a new <code>FtcsSolver</code> instance.","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","diffusion coefficient * dt / dx^2.","Create a new <code>FtcsSolver</code> instance.","Maximum number of time steps.","","","","","","","Initial values of <code>u</code>.",""],"i":[0,0,0,0,0,0,0,10,0,0,14,14,14,14,14,14,14,14,14,14,0,0,0,0,3,0,3,3,3,24,0,0,21,20,21,20,20,20,21,20,20,20,21,20,20,21,21,20,21,21,20,21,20,21,20,21,21,0,0,23,22,23,22,22,22,23,22,22,22,23,22,22,23,22,23,23,22,23,22,23,22,23,23],"f":[0,0,0,[[[2,[1]],3,4,5],[[8,[[7,[6]]]]]],0,0,[9,[[8,[[0,[10,11,12]],[7,[6]]]]]],[[],[[8,[13]]]],0,0,[[]],[[]],[[14,15],16],[[]],[[]],[2,14],[[14,[2,[1]]],[[8,[13]]]],[[],8],[[],8],[[],17],[[4,5,[2,[1]],[2,[1]]],[[8,[18]]]],0,0,0,[[],[[2,[1]]]],0,[[],5],[[],[[8,[[7,[6]]]]]],[[],19],[[],[[8,[13]]]],0,0,[[]],[[]],[[]],[[]],[20,[[2,[1]]]],[[20,15],16],[[]],[[]],[20,5],[20,[[8,[[7,[6]]]]]],[[]],[[]],[20,19],0,0,[21,[[8,[20,13]]]],0,[[],8],[[],8],[[],8],[[],8],[[],17],[[],17],0,[21,[[8,[13]]]],0,0,[[]],[[]],[[]],[[]],[22,[[2,[1]]]],[[22,15],16],[[]],[[]],[22,5],[22,[[8,[[7,[6]]]]]],[[]],[[]],[22,19],0,[23,[[8,[22,13]]]],0,[[],8],[[],8],[[],8],[[],8],[[],17],[[],17],0,[23,[[8,[13]]]]],"c":[],"p":[[15,"f64"],[6,"Array1"],[8,"Solver"],[8,"Write"],[15,"usize"],[8,"Error"],[3,"Box"],[4,"Result"],[8,"Read"],[8,"InputParams"],[8,"Serialize"],[8,"DeserializeOwned"],[15,"str"],[3,"TrinomialEq"],[3,"Formatter"],[6,"Result"],[3,"TypeId"],[3,"Error"],[15,"bool"],[3,"BeamwarmingSolver"],[3,"BeamwarmingSolverNewParams"],[3,"FtcsSolver"],[3,"FtcsSolverNewParams"],[8,"NewParams"]]},\
"solve_diffusion_eq_by_beamwarming_method":{"doc":"Solve the diffusion equation by the …","t":"DLLLLLLMMMMLMLLLL","n":["ExecBeamwarmingInputParams","borrow","borrow_mut","deserialize","fmt","from","into","lambda","mu","n_x","ncycle_out","serialize","step_max","try_from","try_into","type_id","validate_params"],"q":[[0,"solve_diffusion_eq_by_beamwarming_method"]],"d":["Input parameters.","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Weighting factor in differencing scheme.","diffusion coefficient * dt / dx^2.","Number of cells.","Number of cycles between outputs.","","Maximum number of time steps.","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[]],[[]],[1,[[3,[2]]]],[[2,4],5],[[]],[[]],0,0,0,0,[[2,6],3],0,[[],3],[[],3],[[],7],[2,[[3,[8]]]]],"c":[],"p":[[8,"Deserializer"],[3,"ExecBeamwarmingInputParams"],[4,"Result"],[3,"Formatter"],[6,"Result"],[8,"Serializer"],[3,"TypeId"],[15,"str"]]},\
"solve_diffusion_eq_by_ftcs_method":{"doc":"Solve the diffusion equation by the …","t":"DLLLLLLMMMLMLLLL","n":["ExecFtcsInputParams","borrow","borrow_mut","deserialize","fmt","from","into","mu","n_x","ncycle_out","serialize","step_max","try_from","try_into","type_id","validate_params"],"q":[[0,"solve_diffusion_eq_by_ftcs_method"]],"d":["Input parameters.","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","diffusion coefficient * dt / dx^2.","Number of cells.","Number of cycles between outputs.","","Maximum number of time steps.","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[]],[[]],[1,[[3,[2]]]],[[2,4],5],[[]],[[]],0,0,0,[[2,6],3],0,[[],3],[[],3],[[],7],[2,[[3,[8]]]]],"c":[],"p":[[8,"Deserializer"],[3,"ExecFtcsInputParams"],[4,"Result"],[3,"Formatter"],[6,"Result"],[8,"Serializer"],[3,"TypeId"],[15,"str"]]},\
"solve_laplace_eq_by_point_jacobi_method":{"doc":"Solve the diffusion equation by the …","t":"DLLLLLLMMMLLLLL","n":["ExecPointJacobiInputParams","borrow","borrow_mut","deserialize","fmt","from","into","n_iter_max","n_x","n_y","serialize","try_from","try_into","type_id","validate_params"],"q":[[0,"solve_laplace_eq_by_point_jacobi_method"]],"d":["Input parameters.","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Maximum number of iterations.","Number of grids in x direction.","Number of grids in y direction.","","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[]],[[]],[1,[[3,[2]]]],[[2,4],5],[[]],[[]],0,0,0,[[2,6],3],[[],3],[[],3],[[],7],[2,[[3,[8]]]]],"c":[],"p":[[8,"Deserializer"],[3,"ExecPointJacobiInputParams"],[4,"Result"],[3,"Formatter"],[6,"Result"],[8,"Serializer"],[3,"TypeId"],[15,"str"]]},\
"solve_laplace_eq_by_sor_method":{"doc":"Solve the diffusion equation by the …","t":"DLLLLLLMMMMLLLLL","n":["ExecSorInputParams","borrow","borrow_mut","deserialize","fmt","from","into","n_iter_max","n_x","n_y","omega","serialize","try_from","try_into","type_id","validate_params"],"q":[[0,"solve_laplace_eq_by_sor_method"]],"d":["Input parameters.","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Maximum number of iterations.","Number of grids in x direction.","Number of grids in y direction.","Relaxation parameter.","","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[]],[[]],[1,[[3,[2]]]],[[2,4],5],[[]],[[]],0,0,0,0,[[2,6],3],[[],3],[[],3],[[],7],[2,[[3,[8]]]]],"c":[],"p":[[8,"Deserializer"],[3,"ExecSorInputParams"],[4,"Result"],[3,"Formatter"],[6,"Result"],[8,"Serializer"],[3,"TypeId"],[15,"str"]]},\
"solve_transport_eq_by_bad_upwind_method":{"doc":"Solve the transport equation by the bad upwind method, in …","t":"","n":[],"q":[],"d":[],"i":[],"f":[],"c":[],"p":[]},\
"solve_transport_eq_by_good_upwind_method":{"doc":"Solve the transport equation by the good upwind method, in …","t":"","n":[],"q":[],"d":[],"i":[],"f":[],"c":[],"p":[]},\
"solve_wave_eq_by_beamwarming_method":{"doc":"Solve the transport equation by the …","t":"DLLLLLLMMMMLMLLLL","n":["ExecBeamwarmingInputParams","borrow","borrow_mut","deserialize","fmt","from","into","lambda","n_cfl","n_x","ncycle_out","serialize","step_max","try_from","try_into","type_id","validate_params"],"q":[[0,"solve_wave_eq_by_beamwarming_method"]],"d":["Input parameters.","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Weighting factor in differencing scheme.","CFL number.","Number of cells.","Number of cycles between outputs.","","Maximum number of time steps.","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[]],[[]],[1,[[3,[2]]]],[[2,4],5],[[]],[[]],0,0,0,0,[[2,6],3],0,[[],3],[[],3],[[],7],[2,[[3,[8]]]]],"c":[],"p":[[8,"Deserializer"],[3,"ExecBeamwarmingInputParams"],[4,"Result"],[3,"Formatter"],[6,"Result"],[8,"Serializer"],[3,"TypeId"],[15,"str"]]},\
"solve_wave_eq_by_ftcs_method":{"doc":"Solve the transport equation by the …","t":"DLLLLLLMMMLMLLLL","n":["ExecFtcsInputParams","borrow","borrow_mut","deserialize","fmt","from","into","n_cfl","n_x","ncycle_out","serialize","step_max","try_from","try_into","type_id","validate_params"],"q":[[0,"solve_wave_eq_by_ftcs_method"]],"d":["Input parameters.","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","CFL number.","Number of cells.","Number of cycles between outputs.","","Maximum number of time steps.","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[]],[[]],[1,[[3,[2]]]],[[2,4],5],[[]],[[]],0,0,0,[[2,6],3],0,[[],3],[[],3],[[],7],[2,[[3,[8]]]]],"c":[],"p":[[8,"Deserializer"],[3,"ExecFtcsInputParams"],[4,"Result"],[3,"Formatter"],[6,"Result"],[8,"Serializer"],[3,"TypeId"],[15,"str"]]},\
"solve_wave_eq_by_lax_method":{"doc":"Solve the transport equation by the …","t":"DLLLLLLMMMLMLLLL","n":["ExecLaxInputParams","borrow","borrow_mut","deserialize","fmt","from","into","n_cfl","n_x","ncycle_out","serialize","step_max","try_from","try_into","type_id","validate_params"],"q":[[0,"solve_wave_eq_by_lax_method"]],"d":["Input parameters.","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","CFL number.","Number of cells.","Number of cycles between outputs.","","Maximum number of time steps.","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[]],[[]],[1,[[3,[2]]]],[[2,4],5],[[]],[[]],0,0,0,[[2,6],3],0,[[],3],[[],3],[[],7],[2,[[3,[8]]]]],"c":[],"p":[[8,"Deserializer"],[3,"ExecLaxInputParams"],[4,"Result"],[3,"Formatter"],[6,"Result"],[8,"Serializer"],[3,"TypeId"],[15,"str"]]},\
"solve_wave_eq_by_laxwendroff_method":{"doc":"Solve the transport equation by the …","t":"DLLLLLLMMMLMLLLL","n":["ExecLaxwendroffInputParams","borrow","borrow_mut","deserialize","fmt","from","into","n_cfl","n_x","ncycle_out","serialize","step_max","try_from","try_into","type_id","validate_params"],"q":[[0,"solve_wave_eq_by_laxwendroff_method"]],"d":["Input parameters.","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","CFL number.","Number of cells.","Number of cycles between outputs.","","Maximum number of time steps.","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[]],[[]],[1,[[3,[2]]]],[[2,4],5],[[]],[[]],0,0,0,[[2,6],3],0,[[],3],[[],3],[[],7],[2,[[3,[8]]]]],"c":[],"p":[[8,"Deserializer"],[3,"ExecLaxwendroffInputParams"],[4,"Result"],[3,"Formatter"],[6,"Result"],[8,"Serializer"],[3,"TypeId"],[15,"str"]]},\
"solve_wave_eq_by_leapfrog_method":{"doc":"Solve the transport equation by the …","t":"DLLLLLLMMMLMLLLL","n":["ExecLeapfrogInputParams","borrow","borrow_mut","deserialize","fmt","from","into","n_cfl","n_x","ncycle_out","serialize","step_max","try_from","try_into","type_id","validate_params"],"q":[[0,"solve_wave_eq_by_leapfrog_method"]],"d":["Input parameters.","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","CFL number.","Number of cells.","Number of cycles between outputs.","","Maximum number of time steps.","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[]],[[]],[1,[[3,[2]]]],[[2,4],5],[[]],[[]],0,0,0,[[2,6],3],0,[[],3],[[],3],[[],7],[2,[[3,[8]]]]],"c":[],"p":[[8,"Deserializer"],[3,"ExecLeapfrogInputParams"],[4,"Result"],[3,"Formatter"],[6,"Result"],[8,"Serializer"],[3,"TypeId"],[15,"str"]]},\
"solve_wave_eq_by_maccormack_method":{"doc":"Solve the transport equation by the …","t":"DLLLLLLMMMLMLLLL","n":["ExecMaccormackInputParams","borrow","borrow_mut","deserialize","fmt","from","into","n_cfl","n_x","ncycle_out","serialize","step_max","try_from","try_into","type_id","validate_params"],"q":[[0,"solve_wave_eq_by_maccormack_method"]],"d":["Input parameters.","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","CFL number.","Number of cells.","Number of cycles between outputs.","","Maximum number of time steps.","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[]],[[]],[1,[[3,[2]]]],[[2,4],5],[[]],[[]],0,0,0,[[2,6],3],0,[[],3],[[],3],[[],7],[2,[[3,[8]]]]],"c":[],"p":[[8,"Deserializer"],[3,"ExecMaccormackInputParams"],[4,"Result"],[3,"Formatter"],[6,"Result"],[8,"Serializer"],[3,"TypeId"],[15,"str"]]},\
"solve_wave_eq_by_upwind_method":{"doc":"Solve the transport equation by the …","t":"DLLLLLLMMMLMLLLL","n":["ExecUpwindInputParams","borrow","borrow_mut","deserialize","fmt","from","into","n_cfl","n_x","ncycle_out","serialize","step_max","try_from","try_into","type_id","validate_params"],"q":[[0,"solve_wave_eq_by_upwind_method"]],"d":["Input parameters.","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","CFL number.","Number of cells.","Number of cycles between outputs.","","Maximum number of time steps.","","","",""],"i":[0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"f":[0,[[]],[[]],[1,[[3,[2]]]],[[2,4],5],[[]],[[]],0,0,0,[[2,6],3],0,[[],3],[[],3],[[],7],[2,[[3,[8]]]]],"c":[],"p":[[8,"Deserializer"],[3,"ExecUpwindInputParams"],[4,"Result"],[3,"Formatter"],[6,"Result"],[8,"Serializer"],[3,"TypeId"],[15,"str"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
